    
--------------------------------------------------БАЗОВЫЙ JS-----------------------------------------------
    let age = prompt('Сколько лет?', 20);
    alert(`Тебе ${age} лет!`);
//Если использовать ``, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}


'IF/ELSE':
let login = prompt('Введите логин', ' ');
let message = (login == 'Сотрудник') ? 'Привет' :
  (login == 'Директор') ? 'Здарова' :
  (login == ' ') ? 'Нет логина' : ''
alert(message)
    
let login2 = prompt('Введите логин', '')
let message2
if (login2 == 'Сотрудник'){
    message2 = 'Привет'
}else if(login2 == 'Директор'){
    message2 = 'Здарова'
}else if(login2 == ' '){
    message2 = 'Нет логина'
}alert(message2);


let login;
let password;
login = prompt('Введи логин', '')
if (login == 'Админ') {
    password = prompt('Введи пароль', '');
    if(password == 'Я главный'){
        alert('Вход разрешён')
    } else{
        alert('Неверный пароль')
    }
} else{
    alert('Неверный логин')
}



'ЦИКЛЫ':
// Нахождение простых Чисел
function isPrime(n) {
  if (n < 2) {
    return 'Число должно быть больше 1';
  } else if (n === 2) {
    return 'Простое число';
  }

  let i = 2;
  const limit = Math.sqrt(n);

  while (i <= limit) {
    if (n % i === 0) {
      return 'Составное число';
    }
    i +=1;
  }
  return 'Простое число';
}


// SWITCH - CASE
const num = +prompt('Введите число между 0 и 3(включительно): ');
switch(num){
    case 0:
        alert('Вы ввели число 0')
        break
    case 1:
        alert('Вы ввели число 1')
        break
    case 2:
    case 3:
        alert('Вы ввели число 2 или 3')
        break
    default:
      alert('Вы ввели число не из диапазона!')
}


=================='ФУНКЦИИ':=================
//Минимальное через функцию, 2 способа
function min(a, b){
    if (a < b){
        return a
    }
    return b
}
alert(min(10, 2))

function min(a, b) {
  return a < b ? a : b;
}

//Возведение в степень через функцию
function pow(a, b){
    return (a > 0) && (b > 0) ? a**b : prompt('Введи другое', '') 
}
let powI = prompt('Введи число1' , '')
let powB = prompt('Введи число2' , '')
alert(pow(powI, powB))



По функциям: есть Function-Declaration и Function-Expression

// Function Declaration
function sum(a, b) {
  return a + b;
}
// Function Expression
let sum = function(a, b) {
  return a + b;
};

Разница:
Function-Declaration может быть вызвана раньше, чем она объявлена.
sayHi("Вася"); // Привет, Вася
function sayHi(name) {
  alert( `Привет, ${name}` );
}
Если бы это было Function-Expression, то такой код вызвал бы ошибку:
sayHi("Вася"); // ошибка!
let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};


//Ещё пример:
let age = prompt("Сколько Вам лет?", 18);
let welcome = (age < 18) ?  // функция как часть выражения - Expression
  function() { alert("Привет!"); } :
  function() { alert("Здравствуйте!"); };
welcome();


Итого:
1)Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
2)Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
3)Если функция была создана как часть выражения, то это “Function Expression”.
4)Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
5)Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.


Стрелочные Функции:
Образец: let func = (arg1, arg2, ...argN) => expression;

Пример:
let sum = (a, b) => a + b;
/* Эта стрелочная функция представляет собой более короткую форму:
let sum = function(a, b) {
  return a + b;
};
*/
alert(sum(4, 6)); // 10


Стрелочные функции можно использовать так же, как и Function Expression.
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет!') :  //у этой функции нет аргументов, поэтому () - пустые
  () => alert("Здравствуйте!");

welcome();

// Хороший пример использования функций
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

Стрелочные функции очень удобны для простых действий, особенно для однострочных.

Они бывают двух типов:

1)Без фигурных скобок: (...args) => expression – правая сторона выражения: функция вычисляет его
 и возвращает результат. Скобки можно не ставить, если аргумент только один: n => n * 2.
2)С фигурными скобками: (...args) => { body } – скобки позволяют нам писать несколько инструкций
 внутри функции, но при этом необходимо явно вызывать return, чтобы вернуть значение:
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};
alert( sum(1, 2) ); // 3





======================'ОБЪЕКТЫ':=====================
//простейший объект:  user - объект, name & age - имена свойств, 'John' & 30 - значения свойств
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
}
  user.city = 'Volgograd',
Мы можем в любой момент добавить в него новые пары, удалить пары или 
прочитать содержимое любой пары.

Для обращения к значениям используется запись «через точку»:
alert( user.name ); // John
alert( user.age ); // 30

Для удаления свойства мы можем использовать оператор delete:
delete user.age;


Объект, объявленный через const, может быть изменён.
const user = {
  name: "John"
};
user.name = "Pete";
alert(user.name); // Pete   
// но если сделаем user =.. будет ошибка. 
// Менять можно только значение(name) свойств. Не сам объект, заданный через const

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
// это вызовет синтаксическую ошибку
user.likes birds = true

Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. 
Такой способ сработает с любым именем свойства:
let user = {};
// присваивание значения "yes" ключу "likes birds"
user["likes birds"] = 'yes';
// получение значения свойства
alert(user["likes birds"]); // yes
// удаление свойства
delete user["likes birds"];

-----------------------------------------------------------------------------------------------------
Пример:

let user = {
  name: "John",
  age: 30
};
let key = prompt("Что вы хотите узнать о пользователе?", "");
// user[key] - это получение ЗНАЧЕНИЯ по КЛЮЧУ
alert( user[key] ); // John (если ввели "name") и 30(если ввели "age")  

Запись «через точку» такого не позволяет:
let user = {
  name: "John",
  age: 30
};
let key = "name";
alert( user.key ); // undefined

let user = {
  name: "Pete",
  age: 25
};
console.log(user['age'])  // 25

Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit  (fruit = apple. apple: 5)
};
alert( bag.apple ); // 5, если fruit="apple"

Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять 
из переменной fruit.
И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.
-----------------------------------------------------------------------------------------------------------


В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.
function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}
let user = makeUser("John", 30);  //Передаём параметры в функц. А она передаёт их в значения! свойств
alert(user.name); // John

В примере выше название свойств name и age совпадают с названиями переменных. Существуют специальные
короткие свойства для упрощения этой записи.

Вместо name:name мы можем написать просто name:
function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
  };
}

'Проверка существования свойства, оператор «in»'
let user = { age: 30 };
let key = "age"; // связка по ключу. key = ключ(имя) свойства объекта user
alert( key in user ); // true

'FOR/IN'
Для перебора всех свойств объекта используется цикл for..in. 
Этот цикл отличается от изученного ранее цикла for(;;).
Синтаксис:

for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

К примеру, давайте выведем Ключи, а затем Значения объекта user:

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin       просто key - это ключи(имена)
  // значения 
  alert( user[key] ); // John, 30, true      user[key] - это получение ЗНАЧЕНИЯ по КЛЮЧУ
}

Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, как, 
например, let key здесь.
Кроме того, мы могли бы использовать другое имя переменной. 
Например, часто используется вариант "for (let prop in obj)".

let codes = {
  "+49": "Германия",   
  "+41": "Швейцария",
  "+1": "США"
};
for (let code in codes) {
  alert(code); // +49, +41, +1
}
// чтобы первым шёл код Германии надо сделать имена не целочисленными(поставить + в именах)
//Так они выводятся по порядку создания. А целочисл. имена выводят свойства по позрастанию(было бы 1,41,49)


!!! По ключам можно складывать! Т.е:  ключ1 + ключ2 = значение1 + значение2
let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
alert(salaries['John'] + salaries['Ann']) // будет 260

Задача1:
Напишите функцию isEmpty(), которая возвращает true - если у объекта НЕТ свойств, иначе false:
let obj = {}
function isEmpty(){
    for (let key in obj){
        return false
    }
    return true
}
alert(isEmpty(obj)) //выведет true, так как объект пустой

Задача2:
Напишите код для суммирования всех зарплат и сохраните результат в переменной sum

let salaries = {    
  John: 100,
  Ann: 160,
  Pete: 130
};
let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}

Задача3:
Создайте функцию, которая умножает все числовые свойства объекта obj на 2
let menu = {
  width: 200,
  height: 300,
  title: "My menu"    
}
function multiplyNumeric(menu) {
   for(key in menu) {
      if (typeof menu[key] === 'number') {
         menu[key] *= 2;
      }
   }
      return menu
}
let res = multiplyNumeric(menu); 
console.log(res) // вывели { width: 400, height: 600, title: 'My menu' }
----------------------------------------------------------------------------------
*Мы можем использовать Object.assign для клонирования объекта:
let user = {
  name: "John",
  age: 30
};
let clone = Object.assign({}, user);   // теперь в объекте clone будут те же свойства, что и в user

Object.assign(dest, [src1, src2, src3...]) 
//Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest



"Функцию, которая является свойством объекта - называют Методом этого объекта."
// ========== 2 варианта объявления функций в объекте: обычный и сокращённый =========
user = {
  sayHi: function() {      // sayHi здесь - ключ. Значение - тело функции.
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и   sayHi: function(){...}
    alert("Привет");
  }
};
//==========================


'THIS':

let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(this.name);
  }

};
user.sayHi(); // John



Например, здесь одна и та же функция назначена двум разным объектам и
имеет различное значение «this» в вызовах:

function sayHi() {
  alert( this.name );
}

let user = { name: "John" };
let admin = { name: "Admin" };
// Добавляем одну функцию в 2 разных объекта свойством 'f'  
user.f = sayHi; // { name: 'John', f: [Function: sayHi] }
admin.f = sayHi;

user.f(); // John  
admin.f(); // Admin  



Задача2:
// ====== Сложение/Умножение чисел введённых в объект ==== 
let calculator = {
    
    read() {
      this.a = +prompt('Число a?', 0);
      this.b = +prompt('Число b?', 0);
    },
    
    sum() {
      return this.a + this.b;
    },
    
    mul() {
      return this.a * this.b;
    },
  };
  
  calculator.read();
  alert( calculator.sum() );
  alert( calculator.mul() );


Задача3:
//У нас есть объект ladder (лестница), который позволяет подниматься и спускаться:
let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // показывает текущую ступеньку
    alert( this.step );
  }
};
ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0 

//===============================



//===================Функция-Конструктор, оператор "new":========================
Функция-Конструктор Объекта, оператор "new":
1)Имя функции-конструктора должно начинаться с большой буквы.
2)Функция-конструктор должна вызываться только с помощью оператора "new".


function User(name, age) {               
  // this = {};  (неявно)           
 this.login = name;
 this.password = age;
  // return this;  (неявно)
}
let user = new User("Jack", 20); 
alert(user); // { login: 'Jack', password: 20 }


Теперь, если нам будет необходимо создать других пользователей, мы можем просто
вызвать new User("Ann", 18), new User("Alice", 31) и так далее. Данная конструкция гораздо удобнее и читабельнее, 
чем многократное создание литерала объекта.
Это и является основной целью конструкторов – реализовать код для многократного создания 
однотипных объектов.



// "Сложный" кодец:
function User(name) {
  // this = {};    (неявно)
  this.name = name;
  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
  // return this;  (неявно)
}

let obj = new User("John");

obj.sayHi(); // 'Меня зовут: John'

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/

//Для создания сложных объектов есть и более продвинутый синтаксис – классы, 
//JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: 
//таких как Date, Set, и других



// ЗАДАЧА 1: Сделать калькулятор через 'функц-конструкт Calculator'
function Calculator(){
    this.read = function(){
        this.a = +prompt('Число a: ', '')
        this.b = +prompt('Число b: ', '')
    }
    this.sum = function(){
        return this.a + this.b
    }
    this.mul = function(){
        return this.a * this.b
    }
}

let calculator = new Calculator();
calculator.read(); 

alert(calculator.sum())
alert(calculator.mul())


// ЗАДАЧА 2: в value хранится 0. Вводишь числа - они прибавляются к value. 
//Через функцию-конструктор Accumulator(startingValue)
function Accumulator(startingValue) {
  
  this.value = startingValue;
  
  this.read = function() {
    this.value += +prompt('Сколько нужно добавить?', 0);
  }
}
let accumulator = new Accumulator(1);

accumulator.read();
alert(accumulator.value);   // если ввести 5 - прога должна вывести 6
//=============================================================================


(Опциональная цепочка ?. — это быстрый способ выбрать первое «определённое» значение из списка.)

Опциональная цепочка '?.':
'obj?.prop' – возвращает obj.prop если obj существует, в противном случае undefined.

let userAdmin = {
  admin() {
    alert("Я админ");
  }
};
let userGuest = {};

userAdmin.admin?.(); // Я админ
userGuest.admin?.(); // undefined   Если бы не '?.' - была бы Ошибка

Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
//===============================================================


'Символы':

Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.
Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы 
были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный
символ с key в качестве имени.

let id = Symbol("g");
let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
alert(user)  // { name: 'Вася', [Symbol(g)]: 123 }


Символы игнорируются циклом for…in
let id = Symbol("g");
let user = {
  name: "Вася",
  age: 30,
  [id]: 123
};
for (let key in user){
  alert(key);    // name, age (свойства с ключом-символом нет при перечисленн
}  
// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );


А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
let id = Symbol("id");
let user = {
  [id]: 123
};
let clone = Object.assign({}, user);
alert( clone[id] ); // 123
//===============================================================


================================='ЧИСЛА':===================================
Чтобы писать числа с большим количеством нулей:
alert( 7.3e9 );  // 7.3 миллиарда

Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое(!) представление результата.
let num = 1.348
alert(num.toFixed(2)) // '1.35'
Мы можем преобразовать полученное значение в число, используя 
унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(2).
(Math.trunc - Производит удаление дробной части без округления: 3.1 становится 3)

Для дробных чисел в js есть такой прикол:
alert( 0.1 + 0.2 ); // 0.30000000000000004
Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // '0.30'

//===================================================================================
'isNaN(value) преобразует значение в число и проверяет является ли оно NaN':
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
alert( isNaN(5) );  // false
Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. 
Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:


'isFinite(value) возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity':
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
Иногда isFinite используется для проверки, содержится ли в строке число



'parseInt и parseFloat':
Для явного преобразования к числу можно использовать + или Number(). 
НО если строка не является в точности числом, то результат будет NaN:

alert( +"100px" ); // NaN
Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.
Но в реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения: 
например "100px" в CSS.
Так как нам получить числовое значение из таких строк?

Для этого есть функции 'parseInt и parseFloat'.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. 
Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5



---В JavaScript встроен объект Math, который содержит различные математические функции и константы---

1)Math.random()
Возвращает случайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
alert( Math.random() ); // 0.1234567894322

2)Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1

3)Math.pow(n, power)
Возвращает число n, возведённое в степень power
alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

В объекте Math есть множество функций и констант, включая тригонометрические функции и тд.


Задача1:
Создайте функцию readNumber, которая будет запрашивать ввод числового значения до тех пор, 
пока посетитель его не введёт.
Функция должна возвращать числовое значение.
Также надо разрешить пользователю остановить процесс ввода, отправив пустую строку или нажав «Отмена». 
В этом случае функция должна вернуть null.
function readNumber() {

  let num;

  while ( !isFinite(num) ){
     num = prompt("Введите число", 0);
  }

  if (num === null || num === '') return null;

  return num;
}
alert(`Число: ${readNumber()}`);
//===================================================================================

Округление:
Math.floor()
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.

Math.ceil()
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.

Math.round()
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

Math.trunc()
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.



============================'СТРОКИ':==============================
Строки в JavaScript кодируются в UTF-16.

function sum(a, b) {
  return a + b;
}
alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3     прекол обратных ``
Если ставить для всей строки ``, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}
*это называется Шаблонные строки ``

Спецсимволы:
Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, 
используя так называемый «символ перевода строки», который записывается как \n:
let guestList = "Guests:\nJohn\nPete\nMary";
alert(guestList); // Guests:
                          //John
                          //Pete
                          //Mary

let a = '\nUkraine'
alert(a.repeat(5))  // повторится 5 раз с новой строчки

Длина строки:
let a = 'Ukraine';
alert(a.length)   // 7. length - свойство, а не функция, поэтому - без ()


Доступ к символам:  //Для получения символа используйте [] или метод at(он может иметь отрицательные значения)
Лучше использовать метод .at(pos):
let a = 'Ukraine';
alert(a.at(2)) // 'r'
alert(a.at(-1)) // посл. символ - 'e'
alert(a.at(-2)) // предпосл. символ - 'n'
Преимущество метода .at(pos) заключается в том, что он допускает отриц. значения


*Также можно перебрать строку посимвольно, используя for..of:
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}


Изменение регистра:
Методы toLowerCase() и toUpperCase() меняют регистр символов:
let a = 'Ukraine';
alert(a.toUpperCase()) //UKRAINE    это МЕТОДЫ(в отличие от length), а методы - с ()



Поиск Порядкого Номера подстроки:

Первый метод — .indexOf(substr, pos)        substr - подстрока, pos - с какого символа ищем
'Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, 
'на которой располагается совпадение, либо -1 при отсутствии совпадений

let a = 'Widget with id';

alert( a.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( a.indexOf("with") ); // 7
alert( a.indexOf('widget') ); // -1, совпадений нет, регистр
alert( a.indexOf("id") ); //1    ! слово Widget - там есть 'id'.Это не обязательно отдельное слово

Необязательный второй аргумент(substr, pos) позволяет начать поиск с определённой позиции:
let a = 'Widget with id';
alert( a.indexOf('id', 2) ) // 12



includes, startsWith, endsWith :
Современный метод .includes(substr, pos) возвр. true, если в строке есть подстрока substr и false, если нет
Это — правильный выбор, если нам необходимо проверить, есть ли совпадение:
alert( "Widget with id".includes("Widget") ); // true
alert( "Widget with id".includes("Bye") ); // false

Методы str.startsWith и str.endsWith проверяют, начинается ли и заканчивается ли строка определённой строкой:
alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

str.slice(start, end)
Возвращает часть строки от start до (не включая) end.
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 1) );// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(2) ); // ringify  Если аргумент 'end' отсутствует, slice возвращает символы до конца строки:


Задача1:  Найти все вхождения подстроки(слова) в строке через цикл:

let str = 'Ослик Иа-Иа посмотрел на виадук';
let target = 'Иа'; // цель поика
let pos = 0;

while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Подстрока найдена на позиции: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}


Задача2:  Напишите функцию, возвращающую строку с первым заглавным символом:

function upper(){
    return str.at(0).toUpperCase() + str.slice(1)
}
let str = prompt('Введи слово: ', '')   // украина
alert(upper())   // Украина


Задача3:  Напишите функцию, возвращающую true, если str содержит 'viagra' или 'XXX', а иначе false

let checkSpam = function(){
    if (lowCase.includes('viagra') || lowCase.includes('xxx')){
        return true
    }
    return false
}

let a = prompt('Слово: ', '')
let lowCase = a.toLowerCase();
alert(checkSpam())


Задача4: Создайте функцию, которая проверяет длину строки str и, если она >10, заменяет конец str на "…", так, 
чтобы её длина стала равна 10

function length(){
  if (str.length > 10){
    alert('Теперь строка длиной в 10 символов')
    return str.slice(0, 9) + '…';
  }
    else return str
}
let str = prompt('Предложение: ', '')   // РоссияУкраина - 13 символов
alert(length())  //РоссияУкр… 

Задача5: Вводится кол-ко валюты. Создайте функцию, которая будет выделять числовое значение и возвращать его.
// Т.е: если ввести 120$ - будет 120(number) / если $120 - 120(string)
let extractCurrencyValue = function(){   // 'Currency - валюта'
  if (value.at(-1) == '$'){
    return parseInt(value)  //type: number. Т.к parseInt() - функция для чисел  120$ => 120
  }
  return value.slice(1)  // type: string  $120 => 120
}
let value = prompt('Введите кол-во долларов: ', '')
alert(extractCurrencyValue())

! При сравнении значений разных типов JavaScript приводит каждое из них к числу !
alert( '21' > 7 ); // true, строка '21' становится числом 21
=================================СТРОКИ УСЁ=================================





===================================='МАССИВЫ'(array):===================================
Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
Существует два варианта синтаксиса для создания пустого массива:
let arr = new Array();
let arr = [];  

В массиве могут храниться элементы любого типа:
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];
alert(arr.at(0)) // Яблоко
alert( arr[1].name ); // Джон
arr[3](); // привет

-----------------Методы pop/push, shift/unshift---------------
Методы, работающие с концом массива:
.pop() удаляет конечный элемент.
.push('item'): добавляет элемент в конец.
Методы, работающие с началом массива:
.shift(): удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
.unshift('item'): добавляет элемент в начало массива

-Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива-

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() );
alert( fruits ); // Яблоко, Апельсин

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits );  // Яблоко, Апельсин, Груша

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); 
alert( fruits ); // Апельсин, Груша

let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

-------------------------------------------------------------

Перебор элементов for..of:
let fruits = ["Яблоко", "Апельсин", "Слива"];
for (let fruit of fruits) {
  alert( fruit );   //Яблоко  Апельсин  Слива
}

Ещё один интересный факт – мы можем перезаписать массив через свойство length:
let arr = [1, 2, 3, 4, 5];
arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]
//Таким образом, самый простой способ очистить массив – это arr.length = 0;


let fruits = ["Яблоки", "Груша", "Апельсин"];
let shoppingCart = fruits;
shoppingCart.push("Банан");  // добавляем в конец
alert( fruits ); // или alert( shoppingCart ), БЕЗ РАЗНИЦЫ, будет  -  [ 'Яблоки', 'Груша', 'Апельсин', 'Банан' ]
Массивы – это объекты. Обе переменные: shoppingCart и fruits являются ССЫЛКАМИ на один и тот же массив.

// Пример того, массивы это объекты(т.е ведут себя как объекты):
У нас есть вызов функции arr[2] как метода объекта. То есть функция получает в качестве this - массив и выводит его:
let arr = ["a", "b"];
arr.push(function() {   // в массив херачим функцию
  alert( this );//this - внутри Функции => внутри Объекта - сслыается на ОБЪЕКТ(если просто внутри Функции - то undefined)
})
arr[2](); // [ 'a', 'b', [Function (anonymous)] ]

--------------------------------------------------------------





-------Методы массивов:------

- .splice():
Метод arr.splice – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы
arr.splice(start, deleteCount, elem1 ... elemN)

Он ИЗМЕНЯЕТ исходный arr начиная с индекса start: удаляет кол-во элементов deleteCount и затем вставляет новые элементы elem1...elemN на их место 
Возвращает массив из удалённых элементов:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

Метод splice также может вставлять элементы без удаления:
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"


- .slice():
Похоже на строковый метод str.slice. 
Метод slice вырезает и возвращает указанную часть массива. Сам массив при этом не изменяется.
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

Можно вызвать slice без аргументов: arr.slice() создаёт копию arr


- .concat():
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов
.concat(arg1, arg2...)
let c = ['e', 'l']
let a = ['a', 'b']
alert(a.concat(c))  // [ 'a', 'b', 'e', 'l ]



- Перебор forEach():
Метод arr.forEach позволяет запускать функцию для каждого элемента массива:

arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
// этот код расскажет о позиции элемента в целевом массиве:  (стрелочная функция): let a = (a, b) => a + b_ alert(a(4, 6))_ 10
["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);  // У Бильбо индекс 0 в Бильбо,Гэндальф,Назгул; и тд
});
Функция вызывается по очереди для каждого элемента массива:
-item – очередной элемент.
-index – его индекс.
-array – сам массив.   // такие названия - чисто по логике. А так их можно заменить на a, b, c


- Поиск в массиве:

.indexOf()/.includes()
У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, что и их 
строковые аналоги, но работают с элементами вместо символов:
arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.

let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true


.find()/.findIndex():  
.find() - нужен для того чтобы найти подмассив с определённым условием
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор ПРЕКРАЩАЕТСЯ
});
Например, у нас есть массив пользователей, каждый из которых имеет поля(свойства) с id и name. 
Найдем пользователя с id == 1:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
let user = users.find((item) => item.id < 3);
alert(user.name); // Вася
"В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен"
'Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1 с одним аргументом. 
'Это типично, другие аргументы этой функции используются редко

У arr.findIndex такой же синтаксис, он ищет ПЕРВЫЙ индекс, на котором был найден элемент, а не сам элемент:
let users = [
  {id: 2, name: "Петя"},
  {id: 4, name: "Вася"},
  {id: 3, name: "Маша"},
  {id: 4, name: "Вася"}
];
alert(users.findIndex((user) => user.name == 'Вася')); // 1


- .filter():  возвращает НОВЫЙ МАССИВ
Метод find() ищет один (первый) элемент, но если найденных элементов может быть много, надо использ .filter()
let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор ПРОДОЛЖАЕТСЯ
  // возвращается пустой массив в случае, если ничего не найдено
});
Пример:
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"}, 
  {id: 3, name: "Маша"}
];
// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter((item) => item.id < 3); 
alert(someUsers); // [ { id: 1, name: 'Вася' }, { id: 2, name: 'Петя' } ]




-Преобразование массива:

.map():
Он вызывает функцию для каждого элемента массива и СОЗДАЁТ НОВЫЙ массив результатов выполнения этой функции.
let result = arr.map(function(item, index, array) {
  // возвращается новый массив
});

// Для каждого элемента массива мы делаем функцию, которая пишет длину элемента
let M = ["Бильбо", "Гэндальф", "Назгул"].map((item) => item + '_MAP');
alert(M); // [ 'Бильбо_MAP', 'Гэндальф_MAP', 'Назгул_MAP' ]


.sort(func):
Сортирует массив, внутрь надо передать функцию.

function compareNumbers(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;//Хз, как это работает(а конкретнее - что делают if? Как эти return помогают сортировке?)
  // или написать вместо if-ов: return a - b. Отсортирует по возрастанию.
}
let arr = [ 1, 12, 5];
arr.sort(compareNumbers);
alert(arr);  // [ 1, 5, 12 ] 


split()/join():
Метод str.split(delim) разбивает строку на массив по заданному разделителю delim:
let names = 'Вася, Петя, Маша';
let arr = names.split(', ');  // alert(arr) был бы: [ 'Вася', 'Петя', 'Маша' ]
for (let name of arr) {
  alert( `Сообщение получат: ${name}` ); // Сообщение получат: Вася (и тд)
}
Вызов split('') разбил бы строку на массив букв.

Вызов .join(glue) делает в точности противоположное split()
Он создаёт строку из элементов arr, вставляя glue между ними
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); 
alert( str ); // Вася;Петя;Маша


-------------------------------------------------------------------
.reduce():

-Когда нам нужно перебрать массив – мы можем использовать 'forEach, for или for..of'.

-Когда нам нужно перебрать массив и вернуть НОВЫЙ массив – мы можем использовать '.map()'.

-Метод arr.reduce похож на методы выше, но немного сложнее. Он используется для вычисления 
единого значения на основе всего массива.

let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
},initial);

-accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если initial есть),
-item – очередной элемент массива,
-index – его позиция,
-array – сам массив.
'Первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих 
'вызовов функции. По окончании он становится результатом reduce.

Тут мы получим сумму всех элементов массива одной строкой:
let arr = [1, 2, 3, 4];
let result = arr.reduce((sum, item) => sum + item, 0);
alert(result); // 10
Тут Функция, переданная в reduce, использует только два аргумента, этого обычно достаточно.
------------------------------------------------------------------------


Array.isArray():
Он возвращает true, если value массив, и false, если нет.
let a = ['a', 'b', 'c']
let b = 'ABC'
alert(Array.isArray(a))  // true
alert(Array.isArray(b))  // false




Задача1: Напишите функцию camelize(), которая преобразует строки вида «my-short-string» в «myShortString»:
let camelize = function(){
  return a
  .split('-')
  .map((item, index) => index == 0 ? item : item[0].toUpperCase() + item.slice(1))
  .join('')
}

let a = prompt('Введи строку: ', '')
alert(camelize())  //: long-ses => longSes


Задача2: Напишите функцию filterRange(), которая принимает массив arr, ищет элементы со значениями 
больше или равными 'a' и меньше или равными 'b' и возвращает новый результат в виде массива.
function filterRange(a, b){
  return arr.filter((number) => ((number >= a) && (number <= b)))
}

let arr = [3, 7, 1, 10, 2, 80]
let newArr = filterRange(3, 10)

alert(arr)  // выводим неизменённый старый массив  [ 3, 7, 1, 10, 2, 80 ]
alert(newArr)  // выводим новый, изменённый по условию  [ 3, 7, 10 ]


Задача4: У нас есть массив строк arr. Нужно отсортировать его.
function copySorted(arr) {
  return arr.slice().sort();  // сортируем копию
}
let sorted = copySorted(["HTML", "JavaScript", "CSS"]);
alert(sorted)


Задача5: Есть Массив объектов - надо вывести из него массив именн пользователей, по ключам 'name':
let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };
let users = [ vasya, petya, masha ];

let names = users.map(item => item.name)
alert(names)  // [ 'Вася', 'Петя', 'Маша' ]  МЕТОД .map() ВОЗВРАЩАЕТ МАССИВ 


Задача6: Отсортировать пользователей по возрасту
Напишите функцию sortAge(), которая принимает массив объектов со свойством age и сортирует их по нему

function sortByAge(arr) {
  return arr.sort((a, b) => a.age > b.age ? 1 : -1);
}
let petya = { name: "Петя", age: 30 };
let vasya = { name: "Вася", age: 25 };
let masha = { name: "Маша", age: 28 };
let arr = [ vasya, petya, masha ];

alert(sortByAge(arr));  //{ name: 'Вася', age: 25 },
                        //{ name: 'Маша', age: 28 },
                        //{ name: 'Петя', age: 30 }


Задача7: Получить средний возраст
Напишите функцию getAverageAge, которая принимает массив объектов со свойством age и возвращает средний возраст
function getAvarageAge(arr){
  return arr.reduce((sum, item) => sum + item.age, 0) / arr.length
}

let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 29 }; // 25 + 30 + 29 = 84

let arr = [ vasya, petya, masha ];

alert(getAvarageAge(arr))  // 84 / 3 =   28




-----------------------------------Map()/Set() и их Методы перебора-------------------------------------
Map() – коллекция пар ключ-значение(Главное отличие от обычного Object - в Map() Объекты МОГУТ быть ключами)
const mp = new Map()
mp.set('name1', 'Danila')
mp.set('name2', 'Yura')
mp.set('age', 18)
alert(mp)  // { 'name1' => 'Danila', 'name2' => 'Yura', 'age' => 18 }

*alert(Array.from(mp)) - превращает коллекцию в чистый массив // [ [ 'name1', 'Danila' ],[ 'name2', 'Yura' ],[ { age: 18 }, undefined ] ]

// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
// map.size – возвращает текущее количество элементов.

// map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает парой: Ключ + Значение

Set() –  Множество, коллекция УНИКАЛЬНЫХ значений:
const values = ['Мышь', 'Орёл', 'Баран', 'Пчела']
const st = new Set(values)
st.add('Мышь')
st.add('Баран')   // Мы добавляем новые элементы, но т.к они - дубликаты, то они не запишутся в множество
alert(st)  // Set(4) { 'Мышь', 'Орёл', 'Баран', 'Пчела' }

function st(values){
  return new Set(values)
}
let values = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Hare", "Hare"];
alert(st(values))  //'{ 'Hare', 'Krishna' }'

//Set имеет те же встроенные методы, что и Map: .keys(); .values(); .entries() 
arr = ['Dom', 'Sad', 'Sad', 'Reka']
let newSet = new Set(arr)
for (let item of newSet.values()){  
    alert(item)
}
---------------------------------------------------------------------------------------------------------------------


===========Для ОБЪЕКТОВ также есть Методы перебора:  keys() values() entries()=========== (тут другой синтаксис)
'Эти методы ПРЕОБРАЗУЮТ Объекты - в Массивы'
Object.keys(сам obj) – возвращает МАССИВ ключей.
Object.values(сам obj) – возвращает МАССИВ значений.
Object.entries(сам obj) – возвращает МАССИВ пар [ключ, значение]  (а раз это МАССИВЫ, то для них уже можно использ. map() filter() и тд)
Object.fromEntries(array) – превращает МАССИВ пар [ключ, значение] обратно в ОБЪЕКТ

let user = {
  name: "John",
  age: 30
};
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]
* .trim() - удаляет пробелы с обеих концов строки


let user = {
  name: "John",
  age: 30
};
for (let value of Object.values(user)) {
  alert(value); // John, 30
}

Задача1: возвращает удвоенное значение объекта:
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};
let doublePrices = Object.fromEntries(    // преобразовать в массив, затем map, затем fromEntries делает обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])  // key - это banana, value - 1 
);
alert(doublePrices); // { banana: 2, orange: 4, meat: 8 }
--------------------------------------------

Задача2: возвращает сумму значений объекта(сумму зарплат):

function sumSalaries(salaries){
  for (let item of Object.values(salaries)){
      sum += item
  }
  return sum
}

let sum = 0
let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert(sumSalaries(salaries))  // 650
-------------------------------------------

Задача3: Напишите функцию count(), которая возвращает количество свойств объекта:
let count = function(user){
  let sum = Object.entries(user)
  return sum.length
}
let user = {
  name: 'John',
  age: 30,
  orientation: 'Gay',
};
alert(count(user)) // 3
-------------------------------------------






========================================'Формат JSON, метод toJSON'=====================================

JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов. Это стандартный текстовый формат для хранения и передачи структурированных данных. 
Он основан на синтаксисе объекта в JavaScript, но не привязан к нему. Работу с ним поддерживают многие современные языки программирования: Python, Java и другие.

JavaScript предоставляет методы:

1) JSON.stringify(value, [replacer, space]) - для преобразования объектов в JSON.
2) JSON.parse() - для преобразования JSON обратно в объект

------------------------------------------------
Чтобы перевести любой Объект в JSON:
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};
let json = JSON.stringify(student) 
alert(json)    =>   {"name":"John","age":30,"isAdmin":false,"courses":["html","css","js"],"wife":null}
-------------------------------------------------

Чтобы перевести JSON-формат обратно в Объект:
let user = '{ "name": "John", "age": 35 }';
user = JSON.parse(user);
alert(user)  // { name: 'John', age: 35 }
alert(typeof(user)) // object

В JSON - ключ ВСЕГДА должен быть в ""

Асинхронные функции:
setInterval( func(){}, delay)
setTimeout( () => {}, delay) 
позволяют выполнять Функции регулярно(setInterval) или только один раз(setTimeout)  после задержки (delay), заданной в мс.








=======================================БРАУЗЕРНЫЙ JS=======================================
DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.
Все операции с DOM начинаются с объекта 'document'. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.

Самые верхние элементы дерева доступны как свойства объекта document:

Доступ к самому верхнему узлу документа: 'document.documentElement'. В DOM это тег '<html>'.
// <html> = document.documentElement

Другой часто используемый DOM-узел – узел тега <body>: document.body.
// <body> = document.body

Тег <head> доступен как document.head
// <head> = document.head


------------Навигация по DOM-элементам, Общая DOM-коллекция children, Дети, Родители/Соседи-------------
ДЕТИ:
Свойства firstElementChild и lastElementChild обеспечивают быстрый доступ к первому и последнему дочернему элементу.
1)elem.children[0] === elem.firstElementChild
2)elem.children[elem.children.length - 1] === elem.lastElementChild  // Всё это СВОЙСТВА, поэтому без ()


Как мы уже видели, 'children' похож на массив. На самом деле это не массив, а Коллекция – особый перебираемый объект-псевдомассив.
for (let node of document.body.children) {
  alert(node); // Перебор коллекции через for..of  -  покажет все узлы из коллекции
}

Методы массивов не будут работать, потому что коллекция – это НЕ массив:
alert(document.body.children.filter); // undefined (у коллекции нет метода filter)  НО
alert( Array.from(document.body.children).filter ); // сделали массив и теперь можем юзать Методы Массивов


! DOM-коллекции – только для чтения !
* Т.е - мы не можем заменить один дочерний узел на другой, просто написав 'children[i] = ...' 
Для изменения DOM требуются другие методы

Соседи: и Родители:
Следующий сосед элемента – доступен по свойству 'nextElementSibling', а предыдущий – в 'previousElementSibling'
Родитель доступен через 'parentElement':
alert( document.body.parentElement === document.documentElement ); // выведет true, <html> === <html>
alert( document.head.nextElementSibling ); // HTMLBodyElement
alert( document.body.previousElementSibling ); // HTMLHeadElement




Это Навигация только по ЭЛЕМЕНТАМ:

Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.
Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только УЗЛЫ-ЭЛЕМЕНТЫ:
СТАРЫЕ:(узлы-элементы + всякое ненужное говно, комментарии там, текстовые-узлы и тд)
childNodes
firstChild, lastChild
nextSibling
parentNode

НОВЫЕ:(только узлы-элементы, суть)
'children' – коллекция детей, которые являются элементами.
'firstElementChild, lastElementChild' – первый и последний дочерний элемент.
'previousElementSibling, nextElementSibling' – соседи-элементы.
'parentElement' – родитель-элемент.

Изменим один из примеров выше: заменим 'childNodes' на 'children'. Теперь цикл выводит только элементы:
<body>
  <div>Начало</div>
  <ul>
    <li>Информация</li>
  </ul>
  <div>Конец</div>
  <script>
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
    document.body.children[2]  // - выведет <div>Конец</div>
  </script>
</body>



------------------------------Поиск: методы getElement(), querySelector() и другие------------------------------
Свойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет?
Тут появляются методы Поиска произвольного элемента

1) document.getElementById(id)  -  возвращает ОДИН элемент по указанному id
<div id="elem">
    <div id="elem-content">Element</div>
</div>
<script>
    let a = document.getElementById('elem')  
    alert(a)  // '[object HTMLDivElement]'
</script>


2) document.querySelectorAll()  -  возвращает коллекцию
Самый универсальный метод поиска. Он возвращает все элементы по данному CSS-селектору в СВОЮ КОЛЛЕКЦИЮ NodeList:
<ul class="list">
  <li>
     <p class="text"></p>
  </li>
  <li>
     <p></p>
  </li>
  <li>
     <p></p>
  </li>
</ul>
a = document.querySelectorAll('.list li')  -  находит все li внутри .list
    // for (element of a){
    //     alert(element)
    // }
alert(a.length)  // 3


3) document.querySelector()  -  возвр. элемент
Метод elem.querySelector(css) возвращает 1й элемент, соответствующий данному CSS-селектору.
Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0]


4) .matches()
Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.
Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, 
которые нас интересуют.
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
for (let elem of document.querySelectorAll('a')) {   // коллекция из всех тегов <a>
    if (elem.matches('a[href]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }  
// пробегаемся по коллекции всех элементов, если тег 'a' с атрибутом href = true   выводим alert()
</script>


5) .closest()  -  возвр. элемент
Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент ТАКЖЕ включается в поиск.
<h1>Содержание</h1>
<div class="contents">
  <ul class="book">
    <li class="chapter__class">Глава 1</li>
    <li class="chapter__class">Глава 2</li>
  </ul>
</div>

let chapter = document.querySelector('.chapter__class');   // LI

alert(chapter.closest('.book'));     // UL
alert(chapter.closest('.chapter__class')); // li, ведь сам элемент ТАКЖЕ включается в поиск
alert(chapter.closest('h1')); // null (потому что h1 - не предок)



-------------Тренировка по DOM:--------------
console.log(document.querySelectorAll('#age-table'))
console.log(document.querySelectorAll('#age-table label'))
console.log(document.querySelectorAll('#age-table td')[0])
console.log(document.querySelector('form[name="search-person"]'))  // найти по атрибуту + по значению атрибута

// 1й элемент
console.log(document.querySelector('form input'))
// последний элемент 
let inputs = document.querySelectorAll('form[name="search"] input')    // найти все input в form с name='search'
console.log(inputs[inputs.length-1])            // взять последний
------------------------------------------------------------------




-------------------------------Классы DOM-узлов:-------------------------------

Узнать класс(тип) DOM-узла:(HTMLElement, HTMLInputElement, HTMLBodyElement, HTMLAnchorElement, EventTarget...)
1) alert( document.body.constructor.name ); // HTMLBodyElement
2) alert( document.body ); // [object HTMLBodyElement]    (просто приводим к строке)

-------------------
-innerHTML:
Свойство innerHTML объекта Element позволяет установить или возвратить содержимое элемента. Свойство предназначено для работы с HTML разметкой.
*Чтобы ДОБАВИТЬ HTML в документ, а не ЗАМЕНИТЬ содержимое элемента, используйте метод insertAdjacentHTML().

let a = document.querySelector('.text')  // Получаем Объект 
a.innerHTML = '<a>НОВЫЙ ТЕКСТ</a>'      // Перезаписываем в p.text новое значение(на странице автоматом изменится содержимое)
console.log(a.innerHTML)               // Выводим объект вместе с HTML
----------------------------------------

--------------
-data: возвращает содержимое текстового узла(текст без тегов и комментарии)
Прочитаем содержимое текстового узла и комментария:
  'Привет'
  <!-- Комментарий -->
    let text = document.body.firstChild;
    alert(text.data); // Привет

    let comment = text.nextSibling;
    alert(comment.data); // Комментарий
----------------------------------------

--------------
-textContent: просто текст
Свойство textContent предоставляет доступ к тексту внутри тегов
<div id="news"></div>
getElementById('news').textContent = 'Я ГЕЙ'
Можно записывать текст в теги с помощью textContent,
----------------------------------------

--------------
Свойство hidden:
Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет. Технически, hidden работает так же, как style="display:none"
Мы можем использовать его в HTML или назначать при помощи JavaScript

setInterval(() => document.querySelector('a[href]').hidden = !document.querySelector('a[href]').hidden, 1000);  // 1я ссылка МИГАЕТ(появляется-исчезает)
// *Напоминание синтаксиса: setInterval(func, delay)
--------------


В зависимости от своего КЛАССА DOM-узлы имеют и другие свойства. Например у элементов <input>:
-'value' – значение для <input>, (HTMLInputElement)
-'href' – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement)
-'id' – значение атрибута «id» для всех элементов (HTMLElement)
…и многие другие            

Например:
..<input type="text" id="elem" value="ПОЛЕ">   // точки потому шо подсветка синтаксиса ругается на теги

let inputType = document.querySelector('input')
console.log(inputType.type); // "text"
console.log(inputType.id); // "elem"
console.log(inputType.value); // "ПОЛЕ"
--------------


-------------------------------------------------------
Атрибуты
'Получите атрибут':

<div data-widget-name="menu">Choose the genre</div>

let atr = document.querySelector('div[data-widget-name]')
console.log(atr.dataset.widgetName)   // Получили значение атрибута через DATASET. - 'menu'
// Или так: (Методы работы с атрибутами)
console.log(atr.getAttribute('data-widget-name'))  // 'menu'
// Перезаписать атрибут
atr.id = 'new ID'  ИЛИ  atr.setAttribute('id', 'new ID')

Задача: изменить цвет у ссылок, которые содержат '://' и не содержат 'http://internal.com':

let links = document.querySelectorAll('ul li a')
for (let item of links){
    let href = item.getAttribute('href')
    if (href.includes('://') && !href.includes('http://internal.com')){
        item.style.color = 'orange'
    }
}
-------------------------------------------------------



=======================================ИЗМЕНЕНИЕ ДОКУМЕНТА=======================================

-------------------СОЗДАНИЕ ЭЛЕМЕНТА:-------------------
1) document.createElement(tag)  -  Создаёт новый элемент с заданным тегом
   let div = document.createElement('div');
// 2) document.createTextNode(text)  -  Создаёт новый текстовый узел с заданным текстом
//   let textNode = document.createTextNode('А вот и я');
Большую часть времени нам нужно создавать узлы элементов, такие как 'div'

let el = document.createElement('div')  -  мы создали элемент в DOM-структуре, но пока он только в переменной. Мы НЕ МОЖЕМ видеть его на странице, поскольку он не является частью документа.



-------------------ВСТАВКА ЭЛЕМЕНТА: .append() И .insertAdjacentHTML()-------------------

Чтобы наш 'div' появился, нам нужно вставить его где-нибудь в document. Например, в document.body
Например: document.body.append(el)  -  мы вставили элемент с тегом 'div' в document

Полный пример(создание всплывающего окна):
--------------------------------------------------
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

  let a = document.createElement('div');  // -  создаём ЭЛЕМЕНТ с тегом 'div' и присваиваем его 'a'

  a.className = "alert";  // -  задаём этому элементу ' class = "alert" '

  a.innerHTML = "<h1>Всем привет!</h1> Вы прочитали важное сообщение.";  // -  записываем в элемент html код
  document.body.append(a);  // -  вставляем его в document. Теперь он станет видимым.

* '.className' - свойство, которое задает значение атрибута class. (ну короче просто задаёт содержимое класса)

В ИТОГЕ У НАС НА СТРАНИЦЕ БУДЕТ ОКНО
--------------------------------------------------

Вот методы для различных вариантов ВСТАВКИ:

node.append(nodes or strings) – добавляет узлы или строки в конец node,
node.prepend() – вставляет узлы или строки в начало node,
node.before() – вставляет узлы или строки до node,
node.after() – вставляет узлы или строки после node,
node.replaceWith() – заменяет node заданными узлами или строками

Эти методы могут использоваться только для вставки уже созданных DOM-узлов 
А что, если мы хотим вставить HTML именно «как html», со всеми тегами и прочим?

-------------------------------------------------------------------


С этим может помочь другой универсальный метод: .insertAdjacentHTML(where, html)

.insertAdjacentHTML(where, html) 
Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:
"beforebegin" – вставить html непосредственно перед elem,
"afterbegin" – вставить html в начало elem,
"beforeend" – вставить html в конец elem,
"afterend" – вставить html непосредственно после elem.

Второй параметр – это HTML-код

------------------------------------------
Например:
<div id="div"></div>

div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
div.insertAdjacentHTML('beforeend', '<p>Пока</p>');

<p>Привет</p>
<div id="div">
  <p>Пока</p>
</div>
------------------------------------------


ИТОГО:
  -append()/prepend()/before()/after() - ДЛЯ ВСТАВКИ СОЗДАННЫХ ЭЛЕМЕНТОВ(отдельно создаём элемент через .createElement()
  -insertAdjacentHTML()  -  ДЛЯ ВСТАВКИ НОВОГО HTML-кода (херачим всё HTML-ем прямо тут)



---------------------УДАЛЕНИЕ ЭЛЕМЕНТА:---------------------
Для удаления узла есть методы node.remove()
Например: удаление элемента через 3 секунды

let divItem = document.createElement('div');
divItem.className = "alert";
divItem.innerHTML = "<h2>Вот он я, текст элемента</h2>";
document.body.append(divItem);
setTimeout(() => divItem.remove(), 3000);


---------------------КЛОНИРОВАНИЕ ЭЛЕМЕНТА:---------------------
Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.

<div class="alert" id="div">
  <h1>Всем привет!</h1> Вы прочитали важное сообщение
</div>

let div2 = div.cloneNode(true); // клонировать сообщение
div2.querySelector('h1').innerHTML = 'Всем пока!'; // изменить клонированный элемент
div.after(div2); // показать клонированный элемент после существующего div

// ВСЕМ ПРИВЕТ! Вы прочитали важное сообщение
// ВСЕМ ПОКА! Вы прочитали важное сообщение

---------------------РАБОТА С КЛАССАМИ:---------------------
Для управления классами существуют два DOM-свойства:
.className = '' – полностью перезаписывает класс
.classList – объект с методами add()/remove()/toggle()/contains(), может добавлять класс к уже существующему

Методы classList:
.classList.add()/.remove("class") – добавить/удалить класс.
.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
.classList.contains("class") – проверка наличия класса, возвращает true/false.

wrapper.contains('элемент')  - это просто .contains() без classList. Проверяет: содержит ли один элемент внутри себя другой. Возвращает Boolean()

<div class='list'></div>
document.querySelector('.list').classList.add('article');
console.log(document.querySelector('.list'))  //  class='list article'     *а .className сделал бы class='article'

// *getComputedStyle - позволяет получить значение CSS свойства элемента
// let elem = document.querySelector('#elem');
// let style = getComputedStyle(elem); // в style записывает CSS свойства, например 'font-size: 20px'

Лучше использовать Классы(т.е - менять классы в css и перезаписывать их в JS)  а не .style для задания Стилей.

-------------------написать функцию, которая создаст 'окно', со стилями объекта option{}-----------------
let option = {
  top: 30, 
  left: 30, 
  text: 'uppercase',
  color: 'yellow',
  html: "Hello!",
}

function showNotification(option){
  let notification = document.createElement('div')
  notification.classList.add('notification_style')
  
  notification.style.color = option.color
  notification.style.textTransform = option.text

  notification.style.marginTop = option.top + 'px'
  notification.style.marginLeft = option.left + 'px'
  notification.textContent = option.html   // или через  notification.cssText = 'пишем css-стили привычным образом'

  document.body.prepend(notification)
}
showNotification(option)
---------------------------------------------------------------------------------------------------------



=======================================РАЗМЕРЫ ЭЛЕМЕНТОВ=======================================
"Существует множество JavaScript-свойств, которые ПОЗВОЛЯЮТ СЧИТЫВАТЬ информацию об элементе: ширину, высоту и другие геометрические характеристики. В этой главе мы будем называть их «метрики». Они часто требуются, когда нам нужно передвигать или позиционировать элементы с помощью JavaScript"

-------------------------Метрики-------------------------
-elem.offsetParent()
  'В свойстве .offsetParent находится ближайший предок элемента, который:
  __Является CSS-позиционированным (CSS-свойство position равно absolute, relative, fixed или sticky),

-elem.offsetLeft()/.offsetTop()  -  показывает СМЕЩЕНИЕ относительно .offsetParent(родителя)
-----------
<main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 150px; top: 180px">...</div>
  </article>
</main>
  alert(example.offsetParent.id); // main - это батя с каким-нибудь position
  alert(example.offsetLeft); // 150 - это значит элемент смещён вправо на 150px относительно бати с position
  alert(example.offsetTop); // 180 - эл. смещён на 100px вниз
  -----------

-elem.offsetWidth()/Height
  'Содержат: ПОЛНЫЙ размер элемента! (его ширину/высоту + padding + border в px)

//-.clientWidth/Height
//  'Эти свойства включают в себя ширину/высоту области содержимого + padding'

-elem.clientTop()/Left
  'Если внутри элемента у нас есть рамки (border), то эти свойства возвращают их длины в px
---------------
Задача: Расположить Мяч по центру поля field. (считать что у Мяча position: absolute, у Field position: relative, Мяч в поле)
ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
---------------

! -elem.clientX()/.clientY() - координаты элемента относ. окна браузера
  -elem.pageX()/.pageY() - координаты элемента относ. документа

  -.scrollWidth/Height
  Эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.
  Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту.

  -.pageXOffset/.pageYOffset  -  возвращает кол-во пикселей, на которое прокручена страница по гориз. и вертик.


---------------------------Скролл окна----------------------------

Прокрутка: scrollTo, scrollBy, scrollIntoView

1).scrollBy(x,y) прокручивает страницу относительно её текущего положения. Например, scrollBy(0,10) прокручивает страницу на 10px вниз
    window.scrollBy(0, 150) - на 150 вниз

2).scrollTo(pageX,pageY) прокручивает страницу на абсолютные координаты (pageX,pageY). То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа. Для прокрутки в самое начало мы можем использовать scrollTo(0,0)

В ОБОИХ МЕТОДАХ вместо координат(0, 0) также может использоваться объект, КАК АРГУМЕНТ:  
window.scrollBy({  // плавно проскроллит на 500px
  top: 500,
  behavior: "smooth" 
});
// behavior – определяет анимацию('smooth' - плавно, 'instant' - мнгновенно)

3) .scrollIntoView(true/false)  //  - проскроллит так, чтобы верхний край элемент был совмещён с верхней частью окна. Или нижний край с нижней частью окна 

-Запретить/возобновить прокрутку:
    document.body.style.overflow = "hidden"
    document.body.style.overflow = ""



=======================================КООРДИНАТЫ=======================================
'Чтобы передвигать элементы по экрану, нам следует познакомиться с системами координат'

Координаты:
1)Относительно 'Окна браузера' – отсчёт идёт от верхнего левого угла окна.
Обозначаем эти координаты как clientX/clientY
2)Относительно 'Документа' – отсчёт идёт от верхнего левого угла документа.
Будем обозначать эти координаты как pageX/pageY


.getBoundingClientRect() - возвращает массив координат выбранного элемента(x,y,with,height,top,left..)

let box = document.querySelector('button').getBoundingClientRect();
console.log(box)  // вернёт массив координат элемента

.elementFromPoint(x, y) - возвращает элемент, находящийся по координатам (x, y)
-------
Пример: Вывод тега элемента, который находится в центре страницы
let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);
-------

----------------Показать сообщение под элементом-----------------
let elem = document.getElementById("coords-show-mark");

function createMessageUnder(aboba, html) {
  let message = document.createElement('div');
  message.style.cssText = "position:fixed; color: red";  // для стилей лучше было бы использовать css-классы

  let coords = elem.getBoundingClientRect();   

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
}
let message = createMessageUnder(elem, 'Hello, world!');
document.body.append(message);

setTimeout(() => message.remove(), 5000);
---------------------------------


// получаем координаты элемента в контексте документа
function getCoords(aboba) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
---------------------------------




=======================================СОБЫТИЯ=======================================

СОБЫТИЯ(event) это:
-click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
-mouseover / mouseout – когда мышь наводится на / покидает элемент.
-mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
-mousemove – при движении мыши.
-submit – пользователь отправил форму <form>.
-focus – пользователь фокусируется на элементе, например нажимает на <input>.
-keydown и keyup – когда пользователь нажимает / отпускает клавишу.

ОБРАБОТЧИК() событий: element.addEventListener('event', function, [options]);
                      element.removeEventListener('event', function, [options]); 
event - имя события, например "click"
handler - ссылка на функцию-обработчик/сама функция-обработчик
//options - доп. объект со свойствами(once, capture)

--------------
Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента:

<input id="elem" type="button" value="Нажми меня"/>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }
  elem.onclick = () => alert("Привет");  (1)     или: elem.onclick = function(){}    разница: Стрелочная и Обычная
  elem.addEventListener("click", handler1);  Спасибо! (2)
  elem.addEventListener("click", handler2);  Спасибо ещё раз! (2)

  elem.addEventListener( "click" , () => alert('Ура!'));    elem.addEventListener("click", function(e){})

*можно одновременно назначать обработчики и через DOM-свойство(1) и через addEventListener(2)
**Для того чтобы удалить функцию-обработчик:
function handler() {
  alert('1');
}
button.addEventListener("click", handler);
button.removeEventListener("click", handler);
  --------------

--------------------- Объект события: event ---------------------
'Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику'

Пример ниже демонстрирует получение координат мыши из объекта события:
//<input type="button" value="Нажми меня" id="elem">
  document.getElementById('elem').onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };

Некоторые свойства объекта event:
  -event.type  -  возвращает тип события, в данном случае "click".
  -event.currentTarget  -  самый верхний элемент, на который ПОВЕСИЛИ обработчик
  -event.target  -  конкретный элемент
  -event.clientX / event.clientY  -  координаты курсора в момент клика относительно окна браузера

В 'event' - записывается доп. инфа об Элементе на который повесили Событии. Это аргумент функции в обработчике событий.
Грубо говоря, если на кнопку повесили событие 'click' - то в 'event' будет храниться инфа об этой кнопке, с ней можно работать


1) Скрыть Текст при нажатии на кнопку:
let buttonHideText = document.querySelector('#btn')  // выбираем кнопку
buttonHideText.addEventListener('click', function(e){  // вешаем на конпку событие и обработчик(функцию)
  document.querySelector('p').remove()
})

2) При клике по Полю - Элемент перемещается в место клика: (забей хуй на комменты)
let field = document.querySelector('#field')
let ball = document.querySelector('#ball')
//У родителя field - position: relative. Поэтому дочерний отсчитывается от родителя, а не окна браузераи ЗНАЧИТ нужно высчитывать расстояние до краев окна браузера и вычитать его через  -field.offsetLeft
field.addEventListener('click', function(e){
  ball.style.left = e.clientX - field.offsetLeft - ball.width / 2 + 'px';  
  ball.style.top = e.clientY - field.offsetTop - ball.height / 2 + 'px';
// ball.style.left = e.clientX - ball.width / 2 + 'px'    Так можно, если не указывать родителю position: relative
// ball.style.top = e.clientY - ball.height / 2 + 'px'  

// .offsetLeft - это смещение в px от элемента до его Бати(с position)
})

3) Кликаешь по заголовку <p> - появляется/убирается список  // Изначально у <p> - .ul_1: display: none;  .ul_2: display: block;
<p>Сладости:</p>
<ul class="ul_1">
  <li>Пирожное</li>
  <li>Пончик</li>
  <li>Мёд</li>
</ul>
let anchorLink = document.querySelectorAll('p')[1]
anchorLink.addEventListener('click', function(e){
  document.querySelector('.ul_1').classList.toggle('ul_2')
})



--------------------- ВСПЛЫТИЕ И ПОГРУЖЕНИЕ ---------------------
Каждый обработчик имеет доступ к свойствам события event:
Например:
<form id="form">FORM
  <div>DIV
    <p>Text</p>
  </div>
</form>

При клике на <p></p>:
-event.currentTarget(или this)  -  это самый ВЕРХНИЙ элемент, <form>FORM</form>
-event.target  -  это КОНКРЕТНЫЙ элемент, по которому произошёл клик, <p>Text</p>

*Легко возможна и ситуация, когда event.target и event.currentTarget(this) – один и тот же элемент, например, если клик был непосредственно на самом элементе <form>, а не на его под-элементе.



--------------------- ДЕЛЕГИРОВАНИЕ СОБЫТИЙ ---------------------
Делегирование событий - простыми словами, это когда мы вместо прикрепления обработчиков событий к кажому элементу, мы ставим событие родительскому элементу

Для работы ДЕЛЕГИРОВАНИЯ событий нужно 3 шага:
  -Определить родителя элементов для отслеживания событий
  -Прикрепить на него обработчик событий
  -Использовать event.target для выбора целевого элемента   

Пример1:
<div id="buttons">   
  <button class="buttonClass">Click me</button>
  <button class="buttonClass">Click me</button>
  <button class="buttonClass">Click me</button>
</div>

document.getElementById('buttons').addEventListener('click', function(event){ 
    if (event.target.className === 'buttonClass') { 
      console.log('Click!');
    }
});

Step 1. Определить общего родителя элементов для отслеживания событий
В примере <div id="buttons"> является общим родителем для кнопок.

Step 2. Прикрепить к родительскому элементу обработчик событий
document.getElementById('buttons').addEventListener('click', handler) 

Step 3. Использовать event.target для выбора целевого элемента
Когда кнопка нажата, cвойство event.target обращается к элементу, на котором произошло событие (в нашем примере это – кнопка)


Пример2:  Счётчики(проверка через data-атрибуты, а не ,например, классы)
//<input type="button" value="1" data-counter>
//<input type="button" value="2" data-counter>

document.addEventListener('click', function(event) {
  if (event.target.dataset.counter != undefined) { // если есть атрибут...
    event.target.value++;
   }
});

Задача1: при клике на крестик - скрывать блок. Через делегирование
// container - это общий блок-родитель. .pane - класс каждого элемента, который надо скрыть
let container = document.querySelector('#container')
  container.addEventListener('click', function(event){
    if (event.target.className != 'remove-button') return;
    let item = event.target.closest('.pane')
    item.remove()
  })


---------------Отмена действия браузера---------------
Есть два способа отменить действие браузера:

1)Основной способ – это воспользоваться объектом event(через addEventListener)  -  preventDefault().
2)Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.

------ Есть меню - при клике на его ссылки надо, чтобы для них был только alert(), и они НЕ ДЕЛАЛИ свой переход
<ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>
menu.addEventListener('click', function(event){
  if (event.target.nodeTag != 'A') return;

  let href = event.target.getAttribute('href');

  event.preventDefault() // отменить действие браузера (переход по ссылке). Т.е - после нажатия на ссылку - не будет перехода
});
------



-------------------------- ОСНОВЫ СОБЫТИЙ МЫШИ --------------------------
Основные события:
-mouseover/mouseout - Курсор мыши появляется над элементом и уходит с него. (всплывает, работает при делегировании)
  mouseenter/mouseleave - тоже самое, но не всплывает. Не работает при делег.
-mousemove - Каждое движение мыши над элементом
-mousedown/mouseup - Кнопка мыши нажата на элемент/отпущена 
-dblclick - Двойной клик на элементе
-click

Есть события, соответствующие определённой КЛАВИШЕ. Например, если мы хотим, чтобы клик срабатывал только при зажатом SHIFT
Свойства события: 

shiftKey: Shift
altKey: Alt (или Opt для Mac)
ctrlKey: Ctrl
metaKey: Cmd для Mac

<button id="button">Зажми Alt+Shift, что клик сработал на мне!</button>
button.onclick = function(event) {
  if (event.altKey && event.shiftKey) {  // если клик с зажатым alt и shift  -  будет alert
    alert('Ура!');
  }
};

---------------------
Задача: Сделать для списка обычные клики и клики с зажатым ctrl
<ul id="ul">
  <li>Винни Пух</li>
  <li>Пятачок</li>
  <li>Сова</li>
  <li>Кролик</li>
</ul>

ul.addEventListener('click', function(event){  // Делегирование, вешаем обработчик на батю
  if (event.ctrlKey || event.metaKey) { 
    toggleSelect(); // вызываем функцию 1 (если зажат ctrl)
  } 
  else { 
    singleSelect(); // вызываем функцию 2 (если просто клик)
  }
}) 

function toggleSelect() {  // функция для клика при CTRL (1)
  event.target.classList.toggle('selected');  
}

function singleSelect() {   // функция при обычном клике (2)
  let selected = ul.querySelectorAll('.selected');  
  for(let elem of selected) {
    elem.classList.remove('selected');
  }
  event.target.classList.add('selected');
}
---------------------



--------------- Drag'n'Drop ---------------
Базовый алгоритм(1) для Drag'n'Drop:
1)При mousedown – готовим элемент к перемещению
2)Затем при mousemove передвигаем элемент на новые координаты путём смены left/top и position:absolute.
3)При mouseup – остановить перенос элемента и произвести все действия, связанные с окончанием Drag'n'Drop.

Базовый алгоритм(2):
1) В HTML ставим элементу который хотим перетащить атрибут  draggable="true" (если это не картинка и не ссылка)
2) Далее для реализации перемещения УКАЖЕМ В НАШ ОБРАБОТЧИК СОБЫТИЙ эти события: 
  -drag — срабатывает, пока элемент перетаскивается
  -dragstart — срабатывает в момент начала перетаскивания элемента
  -dragend — срабатывает в момент, когда перетаскивание элемента завершено(но не обязательно на целевой области)
  -dragover — срабатывает, пока перетаск. элемент находится над зоной, в которую может быть сброшен, бесконечно срабатывает
  -dragenter — срабатывает, когда элемент заходит в границы целевой области, срабатывает 1 раз 
  -dragleave — срабатывает, когда элемент покидает границы цел. области     (не обязательно заходит полностью, может краешком)
  -drop — срабатывает, когда перетаск. элемент отпускается на ЦЕЛЕВОЙ области


Пример: Drag'n'Drop через drag-события(не как в учебнике)

const dragAndDrop = () => {

  const card = document.querySelector('.js-card');
  const cells = document.querySelectorAll('.js-cell');


  const dragStart = function () {
      setTimeout(() => {
          this.classList.add('hide')});
  };
  const dragEnd = function () {
      this.classList.remove('hide');   // Функции для ПЕРЕТАСКИВАЕМОго элемента
  };

  const dragOver = function (evt) {
      evt.preventDefault();
  };
  const dragEnter = function (evt) {
      this.classList.add('hovered');
  };
  const dragLeave = function () {
      this.classList.remove('hovered');
  };
  const dragDrop = function () {
      this.append(card);
      this.classList.remove('hovered');  // Функции для ЦЕЛЕВОЙ ЗОНЫ
  };

  cells.forEach(cell => {
      cell.addEventListener('dragover', dragOver);
      cell.addEventListener('dragenter', dragEnter);
      cell.addEventListener('dragleave', dragLeave);
      cell.addEventListener('drop', dragDrop);
  });
  card.addEventListener('dragstart', dragStart);
  card.addEventListener('dragend', dragEnd);
} 
dragAndDrop()




--------------- Прокрутка Scroll ---------------
Событие "scroll" - срабатывает когда страница прокручивается
Пример: window.addEventListener('scroll', () => console.log('ПРОКРУТКА'))  - будет выводить в консоль при каждом проскрол. пикселе

------
Задача: При проскролле страницы вниз на 500px - появляется кнопка 'наверх'
<a href="#top" id="back-to-top" class="back-to-top">НАВЕРХ</a> // изначально display: none 

document.addEventListener("DOMContentLoaded", function () {
  const backToTop = document.getElementById("back-to-top");

  // Показать/скрыть кнопку при прокрутке страницы
  window.addEventListener("scroll", function () {
    if (window.pageYOffset > 500) {
      backToTop.style.display = "block";
    } else {
      backToTop.style.display = "none";
    }
  });

  // Плавная прокрутка при клике на кнопку
  backToTop.addEventListener("click", function (event) {
    event.preventDefault();
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
});

*Доп. события: 
 load – все ресурсы загружены (картинки, стили, скрипты и так далее)
 DOMContentLoaded – DOM-дерево полностью построено и готово к работе, без ожидания полной загрузки таблиц стилей, изображений
------




============================== ФОРМЫ ==============================
Навигация:
document.forms[name/index] - находит форму
form.elements[name/index] - находит элементы

События focus и blur срабатывают на фокусировке/потере фокуса элемента.
---------
Пример: если в введённом емейле нет '@'  -  выводить предупреждение

инпут type="email" id="input">
<div id="error"></div>

.invalid { border-color: red; }
  #error { color: red }
  
input.onblur = function() {
  if (!input.value.includes('@')) { // не email
    input.classList.add('invalid');
    error.innerHTML = 'Пожалуйста, введите правильный email.'
  }
};

input.onfocus = function() {
  if (this.classList.contains('invalid')) {
    // удаляем индикатор ошибки, т.к. пользователь хочет ввести данные заново
    this.classList.remove('invalid');
    error.innerHTML = "";
  }
};
---------

*!!!Современный HTML позволяет делать валидацию с помощью атрибутов required, pattern и т.д!!!


-событие и метод submit:
1) Событие submit - код в функции начнёт работать после отправки формы
2) Метод .submit()  - это чтобы отправить форму на сервер вручную,







================================ ПРОДОЛЖАЕМ JS ================================

--------- Деструктурирующее присваивание массивов и объектов ---------
Опр.: Деструктуризация — это особый синтаксис, позволяющий извлекать значения из массива и объекта и записывать их в новые переменные с минимумом кода

*массивы
Без использования деструктуризации: 
const profile = ["Oluwatobi", "Sofela", "codesweetly.com"];
const firstName = profile[0];
const lastName = profile[1];
const website = profile[2];

С использованием:
const profile = ["Oluwatobi", "Sofela", "codesweetly.com"];
const [firstName, lastName, website] = profile;  // в переменные запишутся значения массива

  Оператор "остатка":
  const [firstName, ...otherInfo] = ["Oluwatobi", "Sofela", "codesweetly.com"];
  console.log(firstName); // "Oluwatobi"
  console.log(otherInfo); // ["Sofela", "codesweetly.com"]

let [a, b, c] = ['a', 'b', 'c']
alert(b)  // b = 'b'


*объекты
Без использования деструктуризации: 
const profile = {
  firstName: "Oluwatobi", 
  lastName: "Sofela", 
  website: "codesweetly.com"
};
const firstName = profile.firstName;
const lastName = profile.lastName;
const website = profile.website;

С использованием:
const profile = {
  firstName: "Oluwatobi", 
  lastName: "Sofela", 
  website: "codesweetly.com"
};
const { firstName, lastName, website } = profile;


  Использование деструктуризации объекта, когда имя свойства отличается от имени переменной:
  const profile = {
    firstName: "Oluwatobi", 
    lastName: "Sofela", 
    website: "codesweetly.com"
  }

  const { firstName: forename, lastName: surname, website: onlineSite } = profile;
  console.log(forename); // "Oluwatobi"
  console.log(surname); // "Sofela"
  console.log(onlineSite); // "codesweetly.com"

--------------------------------------------------------------------------



Задача:  Определить сколько раз каждый элемент встречается в массиве.

function f(list){
  list.map((el) => {
      if(!newObj[el]){
          newObj[el] = 1
      } else {
          newObj[el]++
      }
  })
      return newObj
  }
  const fruits = ['kiwi', 'apple', 'kiwi', 'orange', 'kiwi', 'apple'] // исходный массив
  const newObj = {}

  alert(f(fruits))  // { kiwi: 3, apple: 2, orange: 1 }


Задача: CadeWars-1  "Автобусные остановки" каждый подмассив - одна остановка
"Есть массив массивов - 1е число подмассива(остановки) - сколько зашло, 2е - сколько вышло"
Вопрос: сколько людей осталось после последней остановки?.
ТРИ ВАРИАНТА 

1)let number = function(busStops){
  let newArray = []
  busStops.forEach((num) => {
      newArray.push(...num)  // newArray = [10, 0, 3, 5, 5, 8]
  })
  
  let evenNum = 0 // сумма зашедших 
  let notEvenNum = 0 // сумма вышедших
  
  newArray.forEach((item, index) => {
      if(index % 2 == 0){
          evenNum += item
      } else {
          notEvenNum += item
      }
  })
  
  stops.push(evenNum - notEvenNum) // вычитаем из Вошедших - Вышедших
  console.log(stops) // [ [ 10, 0 ], [ 3, 5 ], [ 5, 8 ], 5 ] всё верно, 5
}

let stops = [[10,0],[3,5],[5,8]] // ОСТАНОВКИ   10+3+5 - 0+5+8  =  5 чел. должно остаться
number(stops) 


2)let number = (busStops) => {
  for (let stop of busStops) {
    people += (stop[0] - stop[1]);
  }
  return people; // ТОЖЕ 5
}
var people = 0;
let stops = [[10,0],[3,5],[5,8]]



-------------------------------------------------------------------------------------
Операторы REST, SPREAD  ... ;  REST - делает Масив из параметров, SPREAD - РАСКРЫВАЕТ массив в список элементов

1)REST - остаточный оператор. Делает Массив из переданных функции аргументов
function sumAll(...args) { // в args с помощью '...' запишется массив [1, 2, 3]
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}
sumAll(1, 2, 3) // 6. Т.Е - в аргументы Функции ввели ЧИСЛА - а ... сделал из них МАССИВ 

Мы можем положить первые несколько аргументов в переменные, а остальные – собрать в массив с помощью ... rest
function showName(firstName, lastName, ...titles) {
  alert(titles)  // ["Консул", "Император"]
}
showName("Юлий", "Цезарь", "Консул", "Император");


2)SPREAD - оператор расширения. Он извлекает элементы из массива
Допустим, у нас есть массив чисел [3, 5, 1]. Как вызвать для него Math.max?.
Просто так их не вставишь — Math.max ожидает получить список чисел, а не один массив.

let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN


let arr = [3, 5, 1];
alert( Math.max(...arr) ); // 5 (spread "раскрывает" массив в список аргументов  3, 5, 1)

Оператор spread можно использовать и для слияния массивов:
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [...arr, ...arr2];

Как отличить их друг от друга:
1)Если ... располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает неуказанные аргументы и делает из них массив.
2)Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
---------------------------------------------------------------------------------------


function findShort(s){
  let map = s.split(' ') 
  let b = []
  for(let i of map){
      b.push(i.length)
  }
  return Math.min.apply(null, b);
//return Math.min(...b);
}

findShort("Let's travel abroad shall we")  // MIN('we') - 2




---------------------------------------------------------------------
ЗАМЫКАНИЯ: (замкнутая область видимости)
"Замыкание" - Функция, у которой есть доступ к области видимости, сформированной внешней по отношению к ней Функции даже после того, как эта внешняя функция завершила работу. Это значит, что в замыкании могут храниться переменные, объявленные во внешней функции и переданные ей аргументы.

function createCounter() { 

  let count = 0

  return function counter(){ 
      count++
      alert(count)
  }

}
// makeCounter();  Почему не запускается Функция?
// makeCounter();
let incrementCounter = createCounter();
incrementCounter() // 1
incrementCounter() // 2

Мы создали функцию createCounter(), которая создает другую функцию counter(). Внутри функции мы создали переменную count, которая была определена внутри родительской функции. Функция counter() возвращает значение count, увеличивая его на 1. Когда мы вызываем createCounter(), она возвращает функцию counter(), которая имеет доступ к count благодаря замыканию.
Мы также исключили переменную count из Глобальной обл.видимости. К ней можно обратиться только в функции в которой она была создана и в её подфункциях.


РЕКУРСИЯ:
'Рекурсия' - процесс вызова функцией самой себя. 
Функция, которая в своем теле вызывает сама себя, называется рекурсивной функцией.

Пример:(нахождение факториала Рекурсией)
function getFact(n){
  if (n === 1) return // при использ. Рекурсии - нужно делать условие при котором есть return(выход). Это "база рекурсии"
  s *= n
  getFact(n-1)
}
let s = 1

getFact(5) 
console.log(s) // 120
---------------------------------------------------------------------


Задача: сортировка только нечётных чисел массива. Чётные остаются на месте.
function sortArray(array) {
  const odd = array
    .filter((x) => x % 2)
    .sort((a,b) => a - b);
  return array.map((x) => x % 2 ? odd.shift() : x);
}

let arr = [5, 8, 6, 3, 4]
console.log(sortArray(arr))
//Условие: есть Массив чисел. Нужно написать функцию, которая отсортировала бы в порядке возраст. ТОЛЬКО нечётные числа массива, оставив чётные числа - на своих местах
// Т.е из [5, 8, 6, 3, 4]  ==>  [ 3, 8, 6, 5, 4 ]

-----------------------------------------------------------------------------




ПРОТОТИПЫ: (прототипное наследование)

let animal = {
  eats: 'meat'
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; (*)//  animal - ПРОТОТИП для rabbit

ИЛИ:

let rabbit = Object.create(animal, {  // новый способ создания прототипов - через Object.create(), Object.setPrototypeOf()
  jumps: {
    value: true,
  }
})

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // meat (**)
alert( rabbit.jumps ); // true

*alert пытается прочитать свойство rabbit.eats(**), его нет в rabbit, поэтому JavaScript следует по ссылке [[Prototype]] и находит его в animal


Вместо отдельного выноса прототипирования (*) - можно объявлять его прямо в объекте. Цепочка прототипов:
let animal = {
  eats: true,
  walk() {
    alert("Animal walks");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal   // вместо отдельного: rabbit.__proto__ = animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

longEar.walk(); // Animal walks
alert(longEar.jumps); // true (из rabbit)

*Значение __proto__ может быть объектом или null. Другие типы игнорируются.
-----------------------------------------------------------------


Значение THIS в методах Прототипов:

let animal = {
  name: 'Danila',
  speak(){
      alert(this.name + ' + SAS')
  },
}

let rabbit = {
  name: "White Rabbit",
  __proto__: animal,
}

rabbit.speak() // White Rabbit + SAS
animal.speak() // Danila + SAS

------------------------------------------------------------------


ГЕТТЕРЫ:/СЕТТЕРЫ:

let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

Есть два типа свойств объекта:
1) свойства-данные (data properties)
2) свойства-аксессоры (accessor properties). По своей сути - это свойства-ФУНКЦИИ объекта, которые используются для получения ИЛИ присвоения ЗНАЧЕНИЙ из объекта, но во внешнем коде они выглядят как обычные свойства объекта! Т.е вызываются как обычные свойства объекта
Свойства-аксессоры представлены методами: «геттер» get – для чтения и «сеттер» set – для записи. 


Геттер + сеттер в 1м объекте:
let user = {
  name: "John",
  surname: "Lo",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  
  set changeName(value){
      [this.name, this.surname] = value.split(' ')  // деструктуризацией, [this.name, this.surname] = ['Alice', 'Rus']
  }
}

user.changeName = 'Alice Rus'  // передаём value  сеттеру
alert(user.name); // Alice
alert(user.surname); // Rus
alert(user.fullName) // Alice Rus
------------------------------------------------------------



КЛАССЫ:

Базовый синтаксис для классов выглядит так:
class MyClass { // название начинается с заглавной буквы, в camalCase
  cat = 'white'; // так в Классах записываются свойства(обычный ключ+значение)
  constructor(...) { // Конструктор – это просто функция, создающая объект 
    // ...
  }
  method1(...) {} // метод
  method2(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
}

Class - способ создания объекта (который мы создаём через constructor),  его методы, геттеры и сеттеры записываются в MyClass.prototype. 
Т.е КЛАСС - возвращает ОБЪЕКТ, созданный через constructor(){}


Пример1:
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}
// Использование:
let user = new User("Иван"); // Класс объявляется через new - переданные аргументы записывается в constructor
user.sayHi(); // Иван



Чтобы сделать ДОЧЕРНИЙ класс: сlass Child extеnds Parent;  (Теперь класс Alien имеет доступ к методам/свойствам класса Enemy) 

class Enemy {
  constructor(power) {
      this.power = power
  }
  attack = () => console.log(`I'm attacking with a power of ${this.power}!`)
}

class Alien extends Enemy {
  constructor (name, power) {
      this.name = name  // this.name = "Adolf"
      super(power)  // super() - это вызов РОДИТЕЛЬСКОГО конструктора в ДОЧЕРНЕМ Классе 
  }
  sayName = () => console.log(this.name)
}

const alien1 = new Alien("Adolf", 20)
alien1.sayName() // "Adolf"
alien1.attack() // I'm attacking with a power of 20!
------------



В терминах ООП отделение внутреннего интерфейса от внешнего называется: ИНКАПСУЛЯЦИЯ.

ВНУТРЕННИЙ И ВНЕШНИЙ ИНТЕРФЕЙСЫ(на примере Кофеварки)
В объектно-ориентированном программировании Свойства и Методы КЛАССОВ разделены на 2 группы:

1)Внешний интерфейс – методы и свойства, доступные снаружи класса.(кнопки, экраны..)
2)Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.(трубки,батареи..)



!В JavaScript есть два типа полей (свойств и методов) объекта:
 -Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого мы использовали только публичные свойства и методы.
 -Приватные: доступны только внутри класса. Они для внутреннего интерфейса. Также есть "защищённые" поля: они тоже приватные, но с ними могут работать и НАСЛЕДУЮЩИЕ(т.е - дочерние, через extends) Классы. 


 -Защищённые свойства обычно начинаются с префикса '_'. Приватные начинаются с '#': 
 class CoffeeMachine {

  #waterAmount = 0;  
  _milkAmmount = 50;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this.#waterAmount = value;
  }

  constructor(power) {
    this.power = power; // создаём дополн. защищённое свойство:   this._power = 100
    console.log(this.#waterAmmount)  // 0,  к приватным свойствам через '#' - обращение ВНУТРИ Класса
  } 
  // * this в Oбъектах мы, оказывается, можем нормально юзать только внутри ФУНКЦИЙ. Например, если этот log вынести из Конструктора  -  будет ошибка, т.к this вне функций равен глобальному window

}

let coffeeMachine = new CoffeeMachine(100); 

console.log(coffeeMachine.#waterAmount) // ошибка! нельзя обратиться вне Класса. (если юзать  '_'  - ошибки не будет)
console.log(coffeeMachine._milkAmmount) // 50  - ошибки НЕТ
console.log(coffeeMachine.power) // 100


Концепции ООП:
1) Инкапсуляция
2) Наследование Классов(extends, super())
3) Полиморфизм - это тема когда например у нас иерархия наследованных Классов(через extends). И в каждом Классе есть метод sayName(){} в котором например есть this. Так вот при вызове sayName() у разных Классов - он будет возвращать разные данные, в завис. от того - какой Класс его вызвал. 
------------



ЗАДАЧКА: есть число(например 25) => 2 + 5 = 7. Но если в новом числе больше 1 цифры - цикл повторяется(87 => 8 + 7=15  15=> 1 + 5=6)

let n = 87
function sum(num){
   let newArr = String(num).split('').map((item) => {
       return Number(item)  //  [8, 7]
   })
   let secondArr = newArr.reduce((accum, iten) => {
       return accum + iten  // 15
   }, 0)
   
   return String(secondArr).length == 1 ? alert(secondArr) : sum(secondArr) // выведет: 6
 
}
sum(n)

ИЛИ:

let n = 87
function sum(n) {
  if(n < 10) return alert(n);                            // тоже выведет: 6
  return sum(n.toString().split('').reduce((acc, cur) => acc + parseInt(cur), 0));
}
sum(n)
------------



МОДУЛИ: (СТАТИЧЕСКИЕ)
- export class User {
  constructor(name) {
    this.name = name;
  }
}

import{User} from 'File.js'


- Экспорт отдельно от объявления
function sayHi(user) {}
function sayBye(user) {}

export{sayHi, sayBye}

import{sayHi, sayBye} from 'File.js'
sayHi()
sayBye()


- "export/import as"  чтобы изменить имя той функции или переменной, которую импорт./экспорт. - юзаем ключевое слово as:
export function admin(){
  // какая-то важная JS функция в отдельном файле(то бишь - это модуль)
}
import{admin as newLife} from 'File.js'
newLife()
// или:
// export{admin as newLife}
// import {newLife} from 'File.js'
--------

Статические импорты - задают костяк(нужные файлы) скрипта

ДИНАМИЧЕСКИЕ импорты - в отличие от статических - дают работать с Модулями в блоках кода{} в завис. от условий
такой подход позволяет подружать только НУЖЫНЕ файлы, в зависимости от условий. А не подгружать их все разом
async function newImports(){
  if(str == 'да'){
    let getID = await import('./say.js'); // со статич. импортами - была бы ошибка, они объявляются в начале
  }
}
*Динам.импорт возвращает промис(объект). Т.е если в 'say.js' будет функция - ТО, чтобы её вызвать -  getID.function()
ведь функция как бы хранится в возвращённом промисе-объекте
-------------------------------------------------



WebSockets:
"Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером в НЕПРЕРЫВНОМ(в отличие от HTTP) формате"

Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол wss:

let socket = new WebSocket("wss://javascript.info");


Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
'open' – соединение установлено,
'message' – получены данные,
'error' – ошибка,
'close' – соединение закрыто.
!socket.send(data) - это метод: отправляет данные на сервер

let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.addEventListener('open', function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("[str] Меня зовут Джон");
})
socket.addEventListener('message', function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
})
-------------------------------------------------



localStorage: localStorage - это ВЕБ-ХРАНИЛИЩЕ, позволяющее хранить пары ключ-значение прямо в браузере.

Основные особенности localStorage:
1)Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
2)Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера, закрытия вкладки
3)localStorage работает ТОЛЬКО со строками. При передаче нестрокового значения - оно будет преобразовано в строку. 
  При передаче/чтении в localStorage объектов - использовать JSON.stringify/parse

Методы localStorage:
- localStorage.setItem(key, value) – сохранить пару ключ/значение.
- localStorage.getItem(key) – получить значение по ключу key.
- localStorage.removeItem(key) – удалить значение по ключу key.
- localStorage.clear() – удалить всё.
- localStorage.key(index) – получить ключ на заданной позиции.
- localStorage.length – количество элементов в хранилище.

*Нужно использовать Object.keys для получения всех ключей, т.к он не учитывает унаследованные(через прототип) ключи
let keys = Object.keys(localStorage);
for(let key of keys) {
  alert(`${key}: ${localStorage.getItem(key)}`);
}

Событие storage:
Событие 'storage' появляется при изменении localStorage. При этом событие генерируется только на соседних вкладках, принадлежащих этому источнику(обычно - домену), КРОМЕ той самой - которая вызвала эти изменения в localStorage.

Свойства события 'storage':
1)key – ключ, который обновился.
2)oldValue – старое значение.
3)newValue – новое значение.
4)url – url документа, где произошло обновление.
5)storageArea – объект localStorage или sessionStorage, где произошло обновление.

Пример: window.addEventListener('storage', () => {
  
})
-------------------------------------------------



Архитектурная модель(паттерн) для создания динамических Веб-Приложений - MVC: 
Это способ организации кода в логические блоки:  Model  View  Controller

1) MODEL - этот компонент отвечает ЗА данные, которые хранятся и обрабатываются на сервере, структуру приложения.

2) VIEW - этот компонент отвечает ЗА взаимодействие с пользователем(взаимодействие с DOM). То есть код компонента view определяет внешний вид приложения.

3) CONTROLLER - этот компонент отвечает за связь между model и view. Код компонента controller определяет, как приложение реагирует на действия пользователя. По сути, это мозг MVC-приложения.
-------------------------------------------------





